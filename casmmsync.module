<?php
// $Id$

/**
 * @file
 * Synchronizes users and groups from a CASDirectory into Monster Menus.
 *
 * Synchronizes users and groups from a CASDirectory into Monster Menus so they
 * can be assigned permissions prior to logging in to Drupal.
 */

require_once 'casmmsync.admin.inc';

/**
 * Implementation of hook_user()
 */
function casmmsync_user($op, &$edit, &$user) {

}

/**
 * Implementation of hook_cron().
 */
function casmmsync_cron() {

  if ((int)ini_get('max_execution_time') < (int)variable_get('cassmmsync_maxexectime', 300)) {
    ini_set('max_execution_time', (int)variable_get('cassmmsync_maxexectime', 300));
  }
  
  $groups = _casmmsync_sync_users();
  _casmmsync_sync_groups($groups);
}

/**
 * Synchronize all user records.
 *
 * return array An array of groups in which the members were found
 */
function _casmmsync_sync_users() {
  $synced = 0;
  $failed = 0;
  $groups = array();

  $params = array(
    'ADMIN_ACCESS' => variable_get('cassmmsync_adminkey', ''),
    'action'       => 'get_all_users',
    'page'         => 0,
    'include_membership' => 'true',
  );
  $base = variable_get('cassmmsync_path', '');

  // Debugging status output
  if (variable_get('casmmsync_show_debug', FALSE)) {
    print "\n<h2>Syncronizing Users</h2>\n";
    ob_end_flush();
    flush();
  }

  $doc = new DOMDocument;

  while (true) {
//   while ($synced < 1000) {
    if(!$doc->load($base.'?'.http_build_query($params, null, '&')))
      break;

    $xpath = new DOMXPath($doc);
    $xpath->registerNamespace('cas', 'http://www.yale.edu/tp/cas');

    // Sync each user
    foreach ($xpath->query('/cas:results/cas:entry') as $userElement) {
      // Fetch properties from the XML
      $webId = $xpath->query('./cas:user', $userElement)->item(0)->nodeValue;

      $attributes = _casmmsync_get_attributes($xpath, $userElement);
      
      $uid = _casmmsync_sync_user($webId, $attributes);
      if ($uid !== FALSE) {
        $synced++;
        
        // Add our groups to the sync list
        if (isset($attributes['MemberOf']) && is_array($attributes['MemberOf'])) {
          foreach ($attributes['MemberOf'] as $groupId) {
            if (!isset($groups[$groupId]))
              $groups[$groupId] = array();
            $groups[$groupId][] = $uid;
          }
        }
      } else {
        $failed++;
      }
    }


    // Debugging status output
    if (variable_get('casmmsync_show_debug', FALSE)) {
      if ($params['page'] && $params['page'] % 100 == 0)
        print "\n<br/>";
      print '.';
      ob_end_flush();
      flush();
    }

    if ($doc->documentElement->getAttribute('morePagesAvailable') != 'true')
    break;

    $params['page']++;
  }
  
  // Debugging status output
  if (variable_get('casmmsync_show_debug', FALSE)) {
    print "\n<h3>User Synchronization Complete</h3>\n";
    ob_end_flush();
    flush();
  }
  
  watchdog('cron', 'CAS-MM User-Sync completed. @synced users synced. @failed users skipped.', array('@synced' => $synced, '@failed' => $failed));
  
  return $groups;
}

/**
 * Syncronize or create a user.
 * This function is based on the implementation of cas_login_check() and makes use
 * of functions in the cas_module in order to allow the settings of that module to
 * consistantly define user attributes.
 *
 * @param $webId
 *    The user's identifier from the CAS Directory
 * @param $attributes
 *    An array of attributes in the same format as returned by phpCAS
 * @return int User id on success, FALSE on failure.
 */
function _casmmsync_sync_user($webId, $attributes) {
  // Initializatio from cas_login_check()
  $cas_user_register = variable_get('cas_user_register', 1);
  $cas_authmap       = variable_get('cas_authmap', 0);

  $all_roles         = user_roles();
  $cas_roles         = array();
  foreach ($all_roles as $key => $value) {
    if (array_key_exists($key, variable_get('cas_auto_assigned_role', array(DRUPAL_AUTHENTICATED_RID)))) {
      $cas_roles[$key] = $key;
    }
  }

  $cas_attributes      = (int)variable_get('cas_attributes', 0);
  $cas_attributes_uid  = (string)variable_get('cas_attributes_uid', '');
  $cas_attributes_name = (string)variable_get('cas_attributes_name', '');
  $cas_attributes_mail = (string)variable_get('cas_attributes_mail', '');

  $cas_attributes = count($attributes);
  $cas_name = $webId;

  // Implementation beginning at line 173 of cas.module

  if ($cas_attributes && $cas_attributes_uid) {
    $cas_name = cas_attributes_concat($cas_attributes_uid, $attributes);
  }

  $cas_uid = "name";
  if ($cas_attributes && $cas_attributes_uid) {
    if ($cas_authmap) {
      $cas_uid = "init";
    }
    else {
      $cas_uid = "uid";
    }
  }

  /*
   * Invoke hook_auth_transform($op, &$username)
   *
   * Allow other modules to change the login name
   * eg. if phpCAS::getUser() returns a string like it:johndoe:10.10.1.2:200805064255
   * eg. if your cas users in Drupal need to be johndoe@cas
   *
   * Note: this transformation needs to happen before we check for blocked users.
   */
  cas_invoke_auth_transform($cas_name);

  /*
   * Invoke hook_auth_filter($op, &$username)
   *
   * Allow other modules to filter out some cas logins
   * eg. if you want to use cas authentication but only allow SOME people in
   * eg. if you want to filter out people without LDAP home directories
   */
  if (($allow = cas_invoke_auth_filter($cas_name)) === FALSE) {
    drupal_set_message("The user account $cas_name is not available on this site.", "error");
    return FALSE;
  }

  // blocked user check
  if (user_is_blocked($cas_name)) {
    // blocked in user administration
    drupal_set_message("The username $cas_name has been blocked.", "error");
    return FALSE;
  }
  else if (drupal_is_denied('user', $cas_name)) {
    // denied by access controls
    drupal_set_message("The name $cas_name is a reserved username.", "error");
    return FALSE;
  }

  // try to log into Drupal
  if ($cas_authmap) {
    // users are coming from Drupal; no need to use the external_load and the authmap
    $user = user_load(array($cas_uid => $cas_name));
  }
  else {
    // users are external; use authmap table for associating external users
    $user = user_external_load($cas_name);
    if (!$user->uid && variable_get('cas_hijack_user', 0)) {
      $user = user_load(array($cas_uid => $cas_name));
      if ($user->uid) user_set_authmaps($user, array('authname_cas' => $cas_name));
    }
  }

  // If we don't have a user register them.
  if (!$user->uid) {
    if ($cas_user_register == 1) {
      $user_default = array(
        "name" => $cas_name,
        "pass" => user_password(),
        "init" => db_escape_string($cas_name),
        "status" => 1,
        "roles" => $cas_roles,
      );
      if (!$cas_authmap) $user_default['authname_cas'] = $cas_name;
      if ($cas_domain) $user_default['mail'] = $cas_name .'@'. $cas_domain;

      if ($cas_attributes) {
        if ($cas_attributes_name) {
          $user_default['name'] = cas_attributes_concat($cas_attributes_name, $attributes);
        }
        if ($cas_attributes_mail) {
          $user_default['mail'] = cas_attributes_concat($cas_attributes_mail, $attributes);
        }
      }

      // Ignore users that do not have a name as these will collide in the user table anyway.
      if (!strlen(trim($user_default['name']))) {
        return FALSE;
      }
//
//       // Become user 1 to be able to save profile information
//       session_save_session(FALSE);
//       $admin = array('uid' => 1);
//       $user = user_load($admin);

      // now save the user
      $user = user_save("", $user_default);
      watchdog("user", 'new user: %n (CAS)', array('%n' => $user->name), WATCHDOG_NOTICE, l(t("edit user"), "admin/user/edit/$user->uid"));
    }
  }
  // If we do have a user, updated their properties from the attributes if needed
  else {
    $user_default = array(
      "name" => $cas_name,
      "init" => db_escape_string($cas_name),
    );
    if (!$cas_authmap) $user_default['authname_cas'] = $cas_name;
    if ($cas_domain) $user_default['mail'] = $cas_name .'@'. $cas_domain;

    if ($cas_attributes) {
      if ($cas_attributes_name) {
        $user_default['name'] = cas_attributes_concat($cas_attributes_name, $attributes);
      }
      if ($cas_attributes_mail) {
        $user_default['mail'] = cas_attributes_concat($cas_attributes_mail, $attributes);
      }
    }

    // Ignore users that do not have a name as these will collide in the user table anyway.
    if (!strlen(trim($user_default['name']))) {
      return FALSE;
    }

    $changed = FALSE;
    foreach ($user_default as $key => $val) {
      if ($val != $user->$key) {
        $user->$key = $val;
        $changed = TRUE;
      }
    }
    if ($changed) {
      $user = user_save($user, $user_default);
    }
  }

  // final check to make sure we have a good user
  if ($user->uid && $user->uid > 0) {

    // update the roles and reset the password
    $roles = $user->roles;
    foreach ($cas_roles as $role) {
      $roles[$role] = $role;
    }
    $user_up = array(
      "pass" => user_password(),
      "roles" => $roles,
    );
    $user = user_save($user, $user_up);
  }

  return $user->uid;
}

/**
 * Helper method for accessing attribute values.
 *
 * @param $xpath
 *    The DOMXPath object to query
 * @param $userElement
 *    The DOMElement to use as a reference, must contain cas:attribute elements.
 * @return
 *    An array of attributes
 */
function _casmmsync_get_attributes($xpath, $userElement) {
  $attributes = array();
  foreach ($xpath->query('./cas:attribute', $userElement) as $elem) {
    $name = $elem->getAttribute('name');
    $value = $elem->getAttribute('value');

    // If multiple attributes exist, add as an array value
    if (isset($attributes[$name])) {
      // Initialize the array with the existing value
      if (!is_array($attributes[$name])) {
        $existingValue = $attributes[$name];
        $attributes[$name] = array($existingValue);
      }

      $attributes[$name][] = $value;
    } else {
      $attributes[$name] = $value;
    }
  }
  return $attributes;
}

/**
 * Syncronize groups from a list of groups
 *
 * @param array $groups Keys are group-ids, values are an array of members.
 * @return void
 */
function _casmmsync_sync_groups($groups) {
  // Debugging status output
  if (variable_get('casmmsync_show_debug', FALSE)) {
    print "\n<h2>Syncronizing Groups</h2>\n";
    ob_end_flush();
    flush();
  }
  
  // Clear the sync status of all groups. We will mark keepers in the sync process
  // and later delete any not still in the AD.
  db_query('UPDATE {casmmsync_group_map} SET sync_keep = 0');
  
  $synced = 0;
  $idsFound = array();
  foreach ($groups as $groupId => $members) {
    $groupPath = _casmmsync_get_group_path($groupId);
//     var_dump($groupPath);

    $groupTId = mm_content_create_path($groupPath, '_casmmsync_create_group_path_element');
    
//     var_dump($groupTId);
//     return false; // debugging exit.
    
    _casmmsync_record_mapping($groupId, $groupTId);
//     _casmmsync_sync_group_members($groupTId, $members);
    
    // Debugging status output
    if (variable_get('casmmsync_show_debug', FALSE) &&  $synced && $synced % 10 == 0) {
      if ($synced && $synced % 1000 == 0)
        print "\n<br/>";
      print '.';
      ob_end_flush();
      flush();
    }
    
    $synced++;
  }
  
  // _casmmsync_clear_old_groups();
  
  // Debugging status output
  if (variable_get('casmmsync_show_debug', FALSE)) {
    print "\n<h3>Group Synchronization Complete</h3>\n";
    ob_end_flush();
    flush();
  }
}

/**
 * Record a mapping of the group id to the tid and mark the group as existing in
 * the source data.
 *
 * @param string $groupId
 * @param string $groupTId
 * @return void
 */
function _casmmsync_record_mapping($groupId, $groupTId) {
  db_query("UPDATE {casmmsync_group_map} SET sync_keep = 1 WHERE group_id = '%s'", $groupId);
  if (!db_affected_rows()) {
    db_query("INSERT INTO {casmmsync_group_map} (group_id, mmtid, sync_keep) VALUES ('%s', '%d', 1)", $groupId, $groupTId);
  }
}

/**
 * Callback function for mm_content_create_path(). This function will create a
 * a new term (group level) for an element in the group path.
 * 
 * @param int $parentTId
 * @param string $name
 * @param string $alias
 * @param ref array $additionalParams
 * @return int
 *   The term ID of the newly-created term.
 */
function _casmmsync_create_group_path_element($parentTId, $name, $alias, &$additionalParams) {
  return mm_content_add_replace_cat(true, $parentTId, array(
    'name'       => $name,
    'alias'      => $alias,
    'dflt_mode'  => 'r',
  ));
}

/**
 * Given a group AD DN, answer an array of path parts for the group
 *
 * @param string $groupId
 * @return array
 */
function _casmmsync_get_group_path($groupId) {
  // Reverse the DN and trim off the domain parts.
  $path = ldap_explode_dn($groupId, 1);
  unset($path['count']);
  $path = array_slice(array_reverse($path), 2);
  
  // Make the DN parts the names (keys) and use an empty string for the alias (values).
  $path = array_flip($path);
  array_walk($path, '_casmmsync_array_empty_string');
  
  // Prepend the top-level group 
  $path = array_merge(array('.Groups' => 'groups'), $path);
  
  return $path;
}

/**
 * A helper function for returning an empty string for array_walk
 *
 * @param ref mixed $value
 * @param mixed $key
 * @return string An empty string.
 */
function _casmmsync_array_empty_string(&$value, $key) {
  $value = '';
}

/**
 * Answer the group name given an AD DN
 *
 * @param string $groupId
 * @return string
 */
function _casmmsync_get_group_name($groupId) {
  $parts = ldap_explode_dn($groupId, 1);
  return $parts[0];
}
